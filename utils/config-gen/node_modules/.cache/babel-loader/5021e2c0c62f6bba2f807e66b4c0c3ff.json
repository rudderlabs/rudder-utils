{"ast":null,"code":"import _initializerDefineProperty from \"/Users/chandu/dev/rudderlabs/rudder-server/utils/config-gen/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/Users/chandu/dev/rudderlabs/rudder-server/utils/config-gen/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/Users/chandu/dev/rudderlabs/rudder-server/utils/config-gen/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _descriptor, _temp;\n\nimport { action, observable, autorun, set, toJS } from 'mobx';\n\nfunction autoSave(store, save) {\n  let firstRun = true;\n  autorun(() => {\n    const connectionsStore = toJS(store);\n    delete connectionsStore.rootStore;\n    const json = JSON.stringify(connectionsStore);\n\n    if (!firstRun) {\n      save(json);\n    }\n\n    firstRun = false;\n  });\n}\n\nexport let ConnectionsStore = (_dec = action.bound, _dec2 = action.bound, (_class = (_temp = class ConnectionsStore {\n  constructor(rootStore) {\n    _initializerDefineProperty(this, \"connections\", _descriptor, this);\n\n    this.rootStore = void 0;\n    this.rootStore = rootStore;\n    this.loadAndSave();\n  }\n\n  loadAndSave() {\n    this.load();\n    autoSave(this, this.save.bind(this));\n  }\n\n  returnWithoutRootStore() {\n    const connectionsStore = toJS(this);\n    delete connectionsStore.rootStore;\n    return connectionsStore;\n  }\n\n  load() {\n    const connectionsStore = localStorage.getItem('connectionsStore');\n\n    if (connectionsStore) {\n      const store = JSON.parse(connectionsStore);\n      set(this, store);\n    }\n  }\n\n  loadImportedFile(connections) {\n    this.connections = connections[0];\n  }\n\n  save(json) {\n    localStorage.setItem('connectionsStore', json);\n  }\n\n  async setConnections(sources) {\n    let connections = {};\n    sources.forEach(source => {\n      connections[source.id] = source.destinations.map(dest => dest.id);\n    });\n    this.connections = connections;\n  }\n\n  async removeConnections(source, destination) {\n    const sourceIds = [source.id];\n    let destinations = this.connections[source.id];\n    let remainingDestinations = destinations.filter(destId => {\n      return destId != destination.id;\n    });\n\n    if (remainingDestinations.length > 0) {\n      this.connections[source.id] = remainingDestinations;\n    } else {\n      delete this.connections[source.id];\n    }\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"connections\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {};\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"setConnections\", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, \"setConnections\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"removeConnections\", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, \"removeConnections\"), _class.prototype)), _class));","map":{"version":3,"sources":["/Users/chandu/dev/rudderlabs/rudder-server/utils/config-gen/src/stores/connections.ts"],"names":["action","observable","autorun","set","toJS","autoSave","store","save","firstRun","connectionsStore","rootStore","json","JSON","stringify","ConnectionsStore","bound","constructor","loadAndSave","load","bind","returnWithoutRootStore","localStorage","getItem","parse","loadImportedFile","connections","setItem","setConnections","sources","forEach","source","id","destinations","map","dest","removeConnections","destination","sourceIds","remainingDestinations","filter","destId","length"],"mappings":"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","sourcesContent":["import { action, observable, trace, autorun, set, toJS } from 'mobx';\n\nimport { IRootStore } from '.';\nimport { ISourceStore } from './source';\nimport { IDestinationStore } from './destination';\n\nexport interface IConnectionsStore {\n  connections: ISourceConnections;\n  rootStore: IRootStore;\n  setConnections(sources: ISourceStore[]): void;\n  removeConnections(source: ISourceStore, destination: IDestinationStore): void;\n  loadAndSave(): any;\n  loadImportedFile(sources: any): any;\n  returnWithoutRootStore(): any;\n}\n\nexport interface ISourceConnections {\n  [key: string]: string[];\n}\n\nfunction autoSave(store: any, save: any) {\n  let firstRun = true;\n  autorun(() => {\n    const connectionsStore = toJS(store);\n    delete connectionsStore.rootStore;\n    const json = JSON.stringify(connectionsStore);\n    if (!firstRun) {\n      save(json);\n    }\n    firstRun = false;\n  });\n}\n\nexport class ConnectionsStore implements IConnectionsStore {\n  @observable connections: ISourceConnections = {};\n  rootStore: IRootStore;\n\n  constructor(rootStore: IRootStore) {\n    this.rootStore = rootStore;\n    this.loadAndSave();\n  }\n\n  public loadAndSave() {\n    this.load();\n    autoSave(this, this.save.bind(this));\n  }\n\n  public returnWithoutRootStore() {\n    const connectionsStore = toJS(this);\n    delete connectionsStore.rootStore;\n    return connectionsStore;\n  }\n\n  public load() {\n    const connectionsStore = localStorage.getItem('connectionsStore');\n    if (connectionsStore) {\n      const store: IConnectionsStore = JSON.parse(connectionsStore);\n      set(this, store);\n    }\n  }\n\n  public loadImportedFile(connections: any) {\n    this.connections = connections[0];\n  }\n\n  public save(json: string) {\n    localStorage.setItem('connectionsStore', json);\n  }\n\n  @action.bound\n  public async setConnections(sources: ISourceStore[]) {\n    let connections: ISourceConnections = {};\n    sources.forEach(source => {\n      connections[source.id] = source.destinations.map(dest => dest.id);\n    });\n    this.connections = connections;\n  }\n\n  @action.bound\n  public async removeConnections(\n    source: ISourceStore,\n    destination: IDestinationStore,\n  ) {\n    const sourceIds = [source.id];\n    let destinations: any = this.connections[source.id];\n    let remainingDestinations = destinations.filter((destId: any) => {\n      return destId != destination.id;\n    });\n    if (remainingDestinations.length > 0) {\n      this.connections[source.id] = remainingDestinations;\n    } else {\n      delete this.connections[source.id];\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}