{"ast":null,"code":"'use strict';\n\nconst maxLength = (array, from, to) => Math.ceil(array.length * Math.log2(from) / Math.log2(to));\n\nfunction baseConvertIntArray(array, {\n  from,\n  to,\n  fixedLength = null\n}) {\n  const length = fixedLength === null ? maxLength(array, from, to) : fixedLength;\n  const result = new Array(length); // Each iteration prepends the resulting value, so start the offset at the end.\n\n  let offset = length;\n  let input = array;\n\n  while (input.length > 0) {\n    if (offset === 0) {\n      throw new RangeError(`Fixed length of ${fixedLength} is too small, expected at least ${maxLength(array, from, to)}`);\n    }\n\n    const quotients = [];\n    let remainder = 0;\n\n    for (const digit of input) {\n      const acc = digit + remainder * from;\n      const q = Math.floor(acc / to);\n      remainder = acc % to;\n\n      if (quotients.length > 0 || q > 0) {\n        quotients.push(q);\n      }\n    }\n\n    result[--offset] = remainder;\n    input = quotients;\n  } // Trim leading padding, unless length is fixed.\n\n\n  if (fixedLength === null) {\n    return offset > 0 ? result.slice(offset) : result;\n  } // Fill in any holes in the result array.\n\n\n  while (offset > 0) {\n    result[--offset] = 0;\n  }\n\n  return result;\n}\n\nmodule.exports = baseConvertIntArray;","map":{"version":3,"sources":["/Users/chandu/dev/rudderlabs/rudder-server/utils/config-gen/node_modules/base-convert-int-array/index.js"],"names":["maxLength","array","from","to","Math","ceil","length","log2","baseConvertIntArray","fixedLength","result","Array","offset","input","RangeError","quotients","remainder","digit","acc","q","floor","push","slice","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAG,CAACC,KAAD,EAAQC,IAAR,EAAcC,EAAd,KAAqBC,IAAI,CAACC,IAAL,CAAUJ,KAAK,CAACK,MAAN,GAAeF,IAAI,CAACG,IAAL,CAAUL,IAAV,CAAf,GAAiCE,IAAI,CAACG,IAAL,CAAUJ,EAAV,CAA3C,CAAvC;;AAEA,SAASK,mBAAT,CAA8BP,KAA9B,EAAqC;AAACC,EAAAA,IAAD;AAAOC,EAAAA,EAAP;AAAWM,EAAAA,WAAW,GAAG;AAAzB,CAArC,EAAqE;AACnE,QAAMH,MAAM,GAAGG,WAAW,KAAK,IAAhB,GAAuBT,SAAS,CAACC,KAAD,EAAQC,IAAR,EAAcC,EAAd,CAAhC,GAAoDM,WAAnE;AACA,QAAMC,MAAM,GAAG,IAAIC,KAAJ,CAAUL,MAAV,CAAf,CAFmE,CAInE;;AACA,MAAIM,MAAM,GAAGN,MAAb;AACA,MAAIO,KAAK,GAAGZ,KAAZ;;AACA,SAAOY,KAAK,CAACP,MAAN,GAAe,CAAtB,EAAyB;AACvB,QAAIM,MAAM,KAAK,CAAf,EAAkB;AAChB,YAAM,IAAIE,UAAJ,CAAgB,mBAAkBL,WAAY,oCAAmCT,SAAS,CAACC,KAAD,EAAQC,IAAR,EAAcC,EAAd,CAAkB,EAA5G,CAAN;AACD;;AAED,UAAMY,SAAS,GAAG,EAAlB;AACA,QAAIC,SAAS,GAAG,CAAhB;;AAEA,SAAK,MAAMC,KAAX,IAAoBJ,KAApB,EAA2B;AACzB,YAAMK,GAAG,GAAGD,KAAK,GAAGD,SAAS,GAAGd,IAAhC;AACA,YAAMiB,CAAC,GAAGf,IAAI,CAACgB,KAAL,CAAWF,GAAG,GAAGf,EAAjB,CAAV;AACAa,MAAAA,SAAS,GAAGE,GAAG,GAAGf,EAAlB;;AAEA,UAAIY,SAAS,CAACT,MAAV,GAAmB,CAAnB,IAAwBa,CAAC,GAAG,CAAhC,EAAmC;AACjCJ,QAAAA,SAAS,CAACM,IAAV,CAAeF,CAAf;AACD;AACF;;AAEDT,IAAAA,MAAM,CAAC,EAAEE,MAAH,CAAN,GAAmBI,SAAnB;AACAH,IAAAA,KAAK,GAAGE,SAAR;AACD,GA3BkE,CA6BnE;;;AACA,MAAIN,WAAW,KAAK,IAApB,EAA0B;AACxB,WAAOG,MAAM,GAAG,CAAT,GAAaF,MAAM,CAACY,KAAP,CAAaV,MAAb,CAAb,GAAoCF,MAA3C;AACD,GAhCkE,CAkCnE;;;AACA,SAAOE,MAAM,GAAG,CAAhB,EAAmB;AACjBF,IAAAA,MAAM,CAAC,EAAEE,MAAH,CAAN,GAAmB,CAAnB;AACD;;AACD,SAAOF,MAAP;AACD;;AACDa,MAAM,CAACC,OAAP,GAAiBhB,mBAAjB","sourcesContent":["'use strict'\n\nconst maxLength = (array, from, to) => Math.ceil(array.length * Math.log2(from) / Math.log2(to))\n\nfunction baseConvertIntArray (array, {from, to, fixedLength = null}) {\n  const length = fixedLength === null ? maxLength(array, from, to) : fixedLength\n  const result = new Array(length)\n\n  // Each iteration prepends the resulting value, so start the offset at the end.\n  let offset = length\n  let input = array\n  while (input.length > 0) {\n    if (offset === 0) {\n      throw new RangeError(`Fixed length of ${fixedLength} is too small, expected at least ${maxLength(array, from, to)}`)\n    }\n\n    const quotients = []\n    let remainder = 0\n\n    for (const digit of input) {\n      const acc = digit + remainder * from\n      const q = Math.floor(acc / to)\n      remainder = acc % to\n\n      if (quotients.length > 0 || q > 0) {\n        quotients.push(q)\n      }\n    }\n\n    result[--offset] = remainder\n    input = quotients\n  }\n\n  // Trim leading padding, unless length is fixed.\n  if (fixedLength === null) {\n    return offset > 0 ? result.slice(offset) : result\n  }\n\n  // Fill in any holes in the result array.\n  while (offset > 0) {\n    result[--offset] = 0\n  }\n  return result\n}\nmodule.exports = baseConvertIntArray\n"]},"metadata":{},"sourceType":"script"}